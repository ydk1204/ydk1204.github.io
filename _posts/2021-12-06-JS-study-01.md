---
layout: post
title: "첫번째 포스팅"
date: 2021-12-06 00:06:23 +0900
excerpt: "자바스크립트 기본기 공부입니다."
tag:
    - markdown
    - sample
comments: true
---

## 기본기 공부 시작

자바스크립트에 대한 기본적인 공부를 했었지만,
기본기는 앞으로도 계속 중요한 요인으로 작용할 것으로 생각되어 복습 및 기록합니다. MDN을 기준으로 공부합니다.
<br>
<br>

### JavaScript

JS는 인터프리터 혹은 컴파일 프로그래밍 언어로, 일급함수를 지원합니다.

<details>
<summary>일급함수</summary>
<div markdown="1">

함수를 다른 변수와 동일하게 다루는 언어는 일급 함수를 가졌다고 표현합니다.
예시로, 일급 함수를 가진 언어에서는 함수를 다른 함수에 매개변수로 제공하거나,
함수가 함수를 반환할 수 있으며, 변수에도 할당할 수 있습니다.

### 예제) 변수에 함수 할당

```Javascript
const foo = function() {
   console.log("foobar");
}
// 변수를 사용해 호출
foo();

```

> 함수가 이름을 가지고 있더라도 할당한 변수 이름을 사용해 함수를 호출할 수 있습니다. 이름을 지정하면 코드를 디버깅할 때 유용합니다.

### 예제) 함수를 인자로 전달

```Javascript
function sayHello() {
   return "Hello, ";
}
function greeting(helloMessage, name) {
  console.log(helloMessage() + name);
}
// `sayHello`를 `greeting` 함수에 인자로 전달
greeting(sayHello, "JavaScript!");

```

> 다른 함수에 인자로 전달된 함수를 콜백 함수라고 합니다. sayHello는 콜백 함수입니다.

### 예제) 함수 반환

```Javascript
function sayHello() {
   return function() {
      console.log("Hello!");
   }
}
```

> 함수가 함수를 반환하는 예제입니다. 자바스크립트에서는 함수를 변수처럼 취급하기 떄문에 함수를 반환할 수 있습니다.
>
> > 함수를 반환하는 함수를 고차 함수라고 부릅니다.

## 변수 사용

```Javascript
const sayHello = function() {
   return function() {
      console.log("Hello!");
   }
}
const myFunc = sayHello();
myFunc();
```

> 만약 sayJello 함수를 직접 호출하면, 반환된 함수를 호출하지 않고 함수 자체를 반환합니다. 그러므로 반환된 함수를 다른 변수에 저장하여 사용합니다.

## 이중 괄호 사용

```Javascript
function sayHello() {
   return function() {
      console.log("Hello!");
   }
}
sayHello()();
```

> 이중 괄호 ()()를 사용해 반환한 함수도 호출한다.

</div>
</details>

<br>

자바스크립트는 프로토타입 기반, 다중 패러다임, 단일 스레드, 동적 언어로, 객체지향형 명령형, 선언형(함수형 프로그래밍 등) 스타일을 지원합니다.

자바스크립트는 동적으로 컨텐츠를 바꾸고, 멀티미디어를 다루고, 움직이는 이미지 그리고 꽤나 많은 다른 일을 진행한다.

1. 변수 안에 값을 저장한다
2. 문자열이라고 불리는 문자들을 조작한다.
3. 웹 페이지상의 이벤트에 응답하는 코드를 작성할 수 있다.

자바스크립트는 **API(Application Programming Interfaces)**라는 것을 사용할 수 있다.
API는 이미 만들어진 코드의 집합체라고 볼 수 있으며, 개발자들이 만들기 어렵고 힘든 부분을 쉽게 구현하도록 하는 프로그램이다.
마치 집에서 가구를 만들 때 직접 디자인하고, 재료를 구하고, 재단하고, 못을 박고 하는 등의 혼자서 모든 것을 하는 대신 가구 만들기 키트를 사는 것과 같다.

**Browser API**는 웹 브라우저에 설치된 API들로, 컴퓨터 환경구성으로 부터 데이터를 보이게 하고 복잡한 일들을 하게 합니다.

-   DOM(Document Object Model) API : 동적으로 페이지의 스타일을 정하는 등 HTML과 CSS를 알맞게 조정하는 역할을 합니다.
-   Geolocation API : 지리적인 정보를 검색하게 해줍니다. 이는 Google MAps가 어떻게 위치를 찾고 지도에 표시하는지 알수 있게 합니다.
-   Audio and Video API : 음악과 비디오를 웹 페이지 상에서 재생하고, 웹캠으로 캡처하고 다른 컴퓨터에 표시하는 등의 멀티미디어를 활용할 수 있는 재미있는 기술을 지원합니다.

**Third party API**는 브라우저에 기본적으로 설치된 API가 아닌 인터넷에서 개인적으로 정보와 코드를 얻어 프로그래밍한 것을 말합니다. 예를 들어,

-   Twitter API : 웹 사이트에 가장 최근의 트윗을 보여줍니다.
-   Google Maps API: 웹 사이트에 원하는 지도를 넣어주고 추가 기능을 지원합니다.

## 웹 페이지에서 자바스크립트는 어떤 일을 하나요?

먼저 브라우저에서 웹페이지를 불러올 때 어떤 일이 발생하는지 생각해봅시다.
브라우저에서 웹페이지를 불러올 때, 실행환경(브라우저) 안에서 HTML, CSS, JavaScript 코드가 실행됩니다. 이는 마치 공장에서 원재료(코드)가 일련의 과정을 거쳐 제품(웹 페이지)으로 탄생되는 것과 갑습니다.

자바스크립트는 HTML과 CSS가 결합되고 웹페이지 상에서 올려진 후, 브라우저의 자바스크립트 엔진에 의해 실행됩니다.

### 브라우저 보안성

각각의 브라우저 탭들은 코드가 싱행되는 개별적인 구성(**실행 환경**)입니다.
이는 각 탭의 대부분의 경우는 오나전히 독립적이고, 하나의 탭의 코드는 다른 탭이나 웹 사이트에 직접적으로 영향을 줄 수 없다는 의미입니다.
이는 보안성에 좋은 방법입니다.

### 자바스크립트 실행 순서

브라우저에서 자바스크립트를 만났을 때 일반적으로는 위에서 아래 순서대로 실행됩니다. 이는 순서에 주의해서 코드를 작성해야한다는 의미입니다.

### 서버측 코드와 클라이언트측 코드

클라이언트측 코드란 사용자의 컴퓨터에서 작동되는 코드입니다. 만약 웹페이지를 보고자 한다면, 클라이언트측 코드가 사용자의 컴퓨터롤 다운로드되고 브라우저가 이를 표시합니다.

반면 서버측 코드는 서버에서 작동되고, 그 결과가 사용자의 브라우저에 넘어가 표시됩니다. PHP, Python 등이 서버측 웹 언어의 대표적인 예라고 볼수 있습니다.
Node.js란 환경을 통해 서버측에서도 자바스크립트가 사용 가능합니다.

### 동적 vs 정적 코드

동적이란 각기 다른 상황에서 적절한 정보가 보이고, 컨텐츠를 웹페이지나 앱 상에 계속 노축시키는 역할을 합니다.

동적으로 바뀌지 않는 페이지를 정적 페이지라고 합니다.

### 스크립트의 로딩 방법

모든 HTML요소는 순서대로 페이지에 로드됩니다. 만약 당신이 자바스크립트를 이용해 HTML 요소를 조작할 경우(DOM), 자바스크립트 코드가 조작 대상인 HTML 요소보다 먼전 실행된다면 조작할 요소가 존재하지 않는 상태이기 때문에 제대로 동작하지 않을 것입니다.

이를 위해 몇가지 해결 방법들이 있습니다.
<br/>
<br/>
**내부 자바스크립트 예제**에서는 다음과 같이 구성하면 됩니다.

```js
document.addEventListener("DOMContentLoaded", function() {
  ...
});
```

이 이벤트리스너는 "DOMContentLoad" 이벤트가 발생되었을 때 함수(function)를 실행한다는 의미입니다.
"DOMContentLoad" 이벤트는 브라우저가 완전히 로드되고 해석될 때 발생합니다.
<br>
function 내부의 자바스크립트 구문은 이벤트가 발생되기 전까지 실행되지 않습니다. 따라서 모든 body 태그의 요소가 로드된 이후 자바스크립트 코드가 실행되도록 만들어 에러를 피한다.

**외부 자바스크립트 예제**에서는 async 속성을 사용하게 됩니다.
일반적으로 HTML 요소를 로딩하는 중 script태그를 만나면 자바스크립트의 내용이 모두 다운될 때까지 HTML 로딩은 멈추게 되는데, async 요소는 비동기 방식으로 script 태그에 도달했을 때 부라우저에게 HTML 요소를 멈추지 않고 다운 받고록 유지시킵니다.

```js
<script src="script.js" async></script>
```

이 경우 script와 HTML은 모두 동시에 로드되고 작동합니다.

예전 방식은 script요소를 body 태그의 맨 끝에 넣는 방법이었습니다.
이 방식을 사용해도 모두 로드된 후 script가 실행되게 만들 수 있습니다.
문제는 HTML DOM이 로드되기 전까지 script의 로딩과 파싱이 완전히 차단된다는 점입니다. 이는 많은 자바스크립트 코드를 다루는 규모가 큰 사이트의 경우 사이트를 느리게 만드는 중요한 성능 문제를 야기할 수 있습니다.

### async & defer

더 깊게 들어가보면 이러한 코드 문제를 해결하기 위한 방법은 실제로 두가지 있습니다. async 와 defer입니다. 두 가지의 차이점은 <br/>

**async** 스크립트는 페이지 렌덩링의 중단 없이 스크립트를 다운로드 하고, 또한 스크립트의 다운로드가 끝나자마자 이를 싱행시킵니다.<br/>
async는 외부 스크립트끼리의 구체적인 실행 순서는 **보장하지 않고**, 단지 나머지 페이지가 나타나는 동안 스크립트가 비동기방식으로 다운로드 되어 중단되지 않는다는 것만 보장합니다.<br/>
async는 각각의 스크립트가 독립적으로, 서로에게 의존하지 않는 관계일 때 적절합니다.

```js
<script async src="js/vendor/jquery.js"></script>

<script async src="js/script2.js"></script>

<script async src="js/script3.js"></script>
```

3개의 스크립트를 로딩하지만 이들의 순서는 보장할 수 없습니다. 이는 script2.js나 script3.js에 있는 함수가 jquery.js의 함수를 사용한다면 에러를 발생될 수 있다는 것을 의미합니다.
<br/>
<br/>

**Defer**는 이와 다르게 순서대로 다운로드 한 후 모든 스크립트와 내용이 다운로드 되었을 때 실행됩니다

```js
<script defer src="js/vendor/jquery.js"></script>

<script defer src="js/script2.js"></script>

<script defer src="js/script3.js"></script>
```

따라서 위의 예제의 경우에는 jquery.js -> script2.js -> script3.js 의 **순서가 보장됩니다.**

#### 요약

-   만약 scirpt들이 각각의 스크립트에 의존하지 않고 독립적으로 파싱되도 상관없다면, **async** 를 사용합니다.
-   먄약 sciprt들이 의존하고 하나의 스크립트가 파싱될때까지 기다려야 한다면, **defer** 를 사용하고 각각의 script 태그들을 실행되길 원하는 순서대로 작성합니다.

Check out the [Jekyll docs][jekyll-docs] for more info on how to get the most out of Jekyll. File all bugs/feature requests at [Jekyll’s GitHub repo][jekyll-gh]. If you have questions, you can ask them on [Jekyll Talk][jekyll-talk].

[jekyll-docs]: https://jekyllrb.com/docs/home
[jekyll-gh]: https://github.com/jekyll/jekyll
[jekyll-talk]: https://talk.jekyllrb.com/
